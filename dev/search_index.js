var documenterSearchIndex = {"docs":
[{"location":"specs/#Example-Component-Specifications","page":"Example Component Specifications","title":"Example Component Specifications","text":"See this paper for details on parameters outlined in the specs below.","category":"section"},{"location":"specs/#Component-Structure","page":"Example Component Specifications","title":"Component Structure","text":"                     ┌───────┐\n          ┌──────────┤ Basin │\n          │          └───────┘\nhas many  │\n          │\n          │\n     ┌────▼───┐    shares a      ┌─────────┐\n     │  Zone  ├──────────────────► Manager │\n     └───┬────┘                  └─────────┘\n         │\nhas many │ ┌───────┐\n         └─► Field │\n           └┬──────┘\n            │\n            │  Rotates many ┌───────┐\n            ├────────────────► Crop │\n            │               └───────┘\n            │\n            │      has a    ┌────────────┐\n            ├───────────────► Irrigation │\n            │               └────────────┘\n            │\n            │      has      ┌──────┐\n            ├───────────────► Pump │\n            │               └──────┘\n            │\n            │      has      ┌─────────────┐\n            └───────────────► WaterSource │\n                            └─────────────┘","category":"section"},{"location":"specs/#Crop","page":"Example Component Specifications","title":"Crop","text":"Defines economic and growth parameters (over four stages) for a given crop.\n\nname: irrigated_barley\ncomponent: Crop\ncrop_type: irrigated_cereal\n\n# values below are given as list of\n# nominal \"best guess\" values, min, and max \n# plant_dates are assumed to be static across all seasons.\n# Identical values for all options are treated as constants\nplant_date: [\"CategoricalParameter\", \"05-31\", \"05-31\", \"05-31\"]\nyield_per_ha: [\"RealParameter\", 3.25, 2.5, 7.0]\nprice_per_yield: [\"RealParameter\", 200.0, 100.0, 250.0]\nvariable_cost_per_ha: [\"RealParameter\", 160.0, 120.0, 350.0]\nwater_use_ML_per_ha: [\"RealParameter\", 2.0, 1.5, 3.0]\nroot_depth_m: [\"RealParameter\", 1.0, 0.8, 1.5]\n# values below were calibrated for North-Central Victoria\net_coef: [\"RealParameter\", 170.0, 170.0, 170.0]\nwue_coef: [\"RealParameter\", 11.4552, 11.4552, 11.4552]\nrainfall_threshold: [\"RealParameter\", 466.43204, 466.43204, 466.43204]\nssm_coef: [\"RealParameter\", 0.4, 0.4, 0.4]\n\n# Effective root zone is roughly half to 2/3rds of root depth\n# https://www.bae.ncsu.edu/programs/extension/evans/ag452-1.html\n# http://dpipwe.tas.gov.au/Documents/Soil-water_factsheet_14_12_2011a.pdf\neffective_root_zone: [\"RealParameter\", 0.55, 0.5, 0.66]\ngrowth_stages:\n  # growth stage length are given in days\n  # harvest date is the sum of all stages\n  initial: \n    stage_length: [\"RealParameter\", 20, 20, 20]\n    crop_coefficient: 0.3\n    depletion_fraction: 0.55\n  development: \n    stage_length: [\"RealParameter\", 25, 25, 25]\n    crop_coefficient: 0.3\n    depletion_fraction: 0.55\n  mid_season: \n    stage_length: [\"RealParameter\", 60, 60, 60]\n    crop_coefficient: 1.15\n    depletion_fraction: 0.55\n  late:\n    stage_length: [\"RealParameter\", 30, 30, 30]\n    crop_coefficient: 0.25\n    depletion_fraction: 0.55","category":"section"},{"location":"specs/#Irrigation","page":"Example Component Specifications","title":"Irrigation","text":"name: gravity\ncomponent: Irrigation\n\n# Cost to install/adopt ($ per ha)\ncapital_cost: [\"RealParameter\", 2000.0, 2000.0, 2500.0]\n\n# water application efficiency\nefficiency: [\"RealParameter\", 0.5, 0.5, 0.9]\n\n# Assumed percentage of capital_cost \nminor_maintenance_rate: [\"RealParameter\", 0.05, 0.05, 0.05]\nmajor_maintenance_rate: [\"RealParameter\", 0.10, 0.10, 0.10]\n\n# Assumed maintenance schedule for minor/major maintenance\n# in years, where 1 is every year, 5 is every 5 years, etc.\nminor_maintenance_schedule: [\"RealParameter\", 1.0, 1.0, 1.0]\nmajor_maintenance_schedule: [\"RealParameter\", 5.0, 5.0, 5.0]\n\n# Assumed average flow rate in ML/day\nflow_ML_day: [\"RealParameter\", 12.0, 12.0, 12.0]\n\n# Range of required head pressure to operate irrigation\nhead_pressure: [\"RealParameter\", 10.0, 8.0, 15.0]","category":"section"},{"location":"specs/#Pump","page":"Example Component Specifications","title":"Pump","text":"Defines the operational costs of a pumping system for surface water and groundwater. Specs for surface_water and groundwater must be defined.\n\nname: surface_water\ncomponent: Pump\n# surface water pump representing an average mix of\n# 60% diesel and 40% electric pumps\n\n# https://publications.csiro.au/rpr/download?pid=csiro:EP1312979&dsid=DS5\n\ncapital_cost: [\"RealParameter\", 18000.0, 18000.0, 70000.0]\nminor_maintenance_schedule: [\"RealParameter\", 1, 1, 1]\nmajor_maintenance_schedule: [\"RealParameter\", 1, 1, 1]\nminor_maintenance_rate: [\"RealParameter\", 0.005, 0.005, 0.005]\nmajor_maintenance_rate: [\"RealParameter\", 0.005, 0.005, 0.005]\npump_efficiency: 0.7\ncost_per_kW: [\"RealParameter\", 0.285, 0.285, 0.285]\nderating: 0.75","category":"section"},{"location":"specs/#WaterSource","page":"Example Component Specifications","title":"WaterSource","text":"Defines the cost of accessing a given water source (surface_water and groundwater must be defined).\n\nname: groundwater\ncomponent: WaterSource\n\n# Surface and Groundwater Account fees: http://www.g-mwater.com.au/downloads/gmw/Pricing_Table_June15.pdf\n# Supply costs taken from East Loddon (North)\n\n# Water Share/Entitlements:\n# http://waterregister.vic.gov.au/water-entitlements/entitlement-statistics\n\n# 4C Lower Campaspe, 52, 1633.5ML\n# Pricing:\n# http://www.g-mwater.com.au/customer-services/myaccount/pricingsimulator\n# http://www.g-mwater.com.au/general-information/pricingsimulator\n\n# http://www.g-mwater.com.au/downloads/gmw/Pricing_Table_June15.pdf\n\n# Definitions:\n# http://waterregister.vic.gov.au/about/water-dictionary\n\n# access_fees are sum of the below\n# in $ per service point\n# service: 100.0\n# infrastructure_access: 2714.0\n# service_point: 300\n# service_point_remote_read: 350\n# service_point_remote_operate: 400\n# surface_drainage_service: 100\nyearly_cost: 3964.0\n\n# area_fee ($/Ha): 7.95\ncost_per_ha:  7.95  # ($/ha)\n\n# access_fee: 2.04\n# resource_management_fee: 4.47\n# high_reliability_entitlement: 24.86\n# low_reliability_entitlement: 15.35\n# high_reliability_storage: 10.57\n# low_reliability_storage: 5.18\n# above_entitlement_storage: 15.35\ncost_per_ML: 77.82  # ($/ML)\n\nhead: 25.0  # Initial head (in meters)\nallocation: 50.0  # Initial allocation","category":"section"},{"location":"specs/#FarmZone","page":"Example Component Specifications","title":"FarmZone","text":"name: Zone_1\ncomponent: FarmZone\n\n# Paths to data, relative to where project is run\nclimate_data: \"test/data/climate/farm_climate_data.csv\"\npump_spec: \"test/data/pumps/\"\n\nfields:\n  field1:\n    name: field1\n    component: CropField\n\n    total_area_ha: 100.0\n    irrigation_spec: \"test/data/irrigations/gravity.yml\"\n\n    # Initial crop is the first one in this list\n    crop_rotation_spec: [\"test/data/crops/irrigated_wheat.yml\", \"test/data/crops/irrigated_barley.yml\"]\n\n    # average soil total available water (mm)\n    soil_TAW: 100.0\n\n    # Initial Soil Water Deficit\n    soil_SWD: 20.0\n\nwater_sources:\n  surface_water:\n    name: surface_water\n    component: WaterSource\n    # Surface and Groundwater Account fees: http://www.g-mwater.com.au/downloads/gmw/Pricing_Table_June15.pdf\n    # Supply costs taken from East Loddon (North)\n\n    # Average volume per licence for the lower Campaspe is ~407ML\n    # (56.2GL / 138 Licences)\n    # see http://www.g-mwater.com.au/downloads/gmw/Groundwater/Lower_Campaspe_Valley_WSPA/Nov_2013_-_Lower_Campaspe_Valley_WSPA_Plan_A4_FINAL-fixed_for_web.pdf\n    # esp. Section 2.2 (Groundwater Use) page 8, \n\n    # Groundwater fees: http://www.g-mwater.com.au/downloads/gmw/Forms_Groundwater/2015/TATDOC-2264638-2015-16_Schedule_of_Fees_and_Charges_-_Groundwater_and_Bore_Construction.pdf\n\n    # Entitlement statistics from http://waterregister.vic.gov.au/water-entitlements/entitlement-statistics\n\n    # Other fees not considered:\n    # Bore Construction fee: $1440\n    # Replacement bore: $900\n    # Each Additional bore: $170\n    # licence amendment: $527 (alter number of bores, alter depth of bore, change bore site)\n    # overuse cost: $2000 / ML (we assume that farmers never over use!)\n\n    # Licence Renewal:\n    # Licence renewal occurs every 5-15 years http://www.g-mwater.com.au/downloads/gmw/Forms_Surface_Water/2015/30_Nov_2015_-_2811974-v10-APPLICATION_TO_RENEW_A_LICENCE_TO_TAKE_AND_USE_SURFACEWATER_OPERATE_WORKS.pdf\n    # Licence Renewal costs $681 (based on 2014-15 fees)\n    # $681 / 5 years, which is $136.2 a year\n\n    # In some cases, farmers may need a licence to perform on-farm MAR\n    # See under section entitled \"Managed Aquifer Recharge (MAR)\"\n    # http://www.srw.com.au/page/page.asp?page_Id=113#BM4730\n\n    # Bore Operation Licence is said to be $1414\n    # Could not find whether this is yearly or every 5 years.\n    # Assuming every 5 years\n    # $1414 / 5 is 282.8\n\n    # http://www.g-mwater.com.au/customer-services/manage-my-account/feedescriptions\n    # http://www.g-mwater.com.au/customer-services/manage-my-account/feesandcharges\n    # http://www.g-mwater.com.au/customer-services/manage-my-account/feesandcharges/yourfeesexplained\n    # yearly_cost is the sum of the below\n    # in $ per service point\n    # service,90\n    # service_point,100\n    # access_service_point,50\n    # bore_operation_licence,282.8\n    # licence_renewal,136.2\n    yearly_cost: 659.0\n\n    # No charge based on area\n    cost_per_ha: 0.0\n\n    # Total fees ($ / ML)\n    # access: 3.96\n    # resource_management: 4.33\n    cost_per_ML: 8.29\n\n    head: 0.0  # Initial head\n    allocation: 225.0  # Initial allocation\n    entitlement: 225.0  # Total entitlement\n\n  groundwater:\n    name: groundwater\n    component: WaterSource\n\n    # Surface and Groundwater Account fees: http://www.g-mwater.com.au/downloads/gmw/Pricing_Table_June15.pdf\n    # Supply costs taken from East Loddon (North)\n\n    # Water Share/Entitlements:\n    # http://waterregister.vic.gov.au/water-entitlements/entitlement-statistics\n\n    # 4C Lower Campaspe, 52, 1633.5ML\n    # Pricing:\n    # http://www.g-mwater.com.au/customer-services/myaccount/pricingsimulator\n    # http://www.g-mwater.com.au/general-information/pricingsimulator\n\n    # http://www.g-mwater.com.au/downloads/gmw/Pricing_Table_June15.pdf\n\n    # Definitions:\n    # http://waterregister.vic.gov.au/about/water-dictionary\n\n    # access_fees are sum of the below\n    # in $ per service point\n    # service: 100.0\n    # infrastructure_access: 2714.0\n    # service_point: 300\n    # service_point_remote_read: 350\n    # service_point_remote_operate: 400\n    # surface_drainage_service: 100\n    yearly_cost: 3964.0\n\n    # area_fee ($/Ha): 7.95\n    cost_per_ha:  7.95  # ($/ha)\n\n    # access_fee: 2.04\n    # resource_management_fee: 4.47\n    # high_reliability_entitlement: 24.86\n    # low_reliability_entitlement: 15.35\n    # high_reliability_storage: 10.57\n    # low_reliability_storage: 5.18\n    # above_entitlement_storage: 15.35\n    cost_per_ML: 77.82  # ($/ML)\n\n    head: 25.0  # Initial head (in meters)\n    allocation: 50.0  # Initial allocation\n    entitlement: 50.0  # Total entitlement","category":"section"},{"location":"specs/#Basin","page":"Example Component Specifications","title":"Basin","text":"name: ExampleBasin\ncomponent: Basin\n\n# Paths to zone specs\nzone_spec: [\"test/data/zones/Zone_1.yml\", \"test/data/zones/Zone_2.yml\"]\n","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"The sections below outline basic use of Agtor.\n\nA complete runnable script can be found here.","category":"section"},{"location":"getting_started/#A-note-on-terminology","page":"Getting Started","title":"A note on terminology","text":"Agtor is a zonal agricultural cropping model, where a zone is defined by a collection of fields, and a basin/catchment is defined with a collection of zones.\n\nField : An area used for cropping, e.g., a field\nFarmZone  : An arbitrary collection of fields, e.g., a farm or sub-catchment\nBasin : An arbitrary collection of zones, e.g., a catchment\n\nIn addition, each zone may be assigned a Manager, simulating an actor in charge of determining irrigation schedules and volume of water use.\n\nCurrently available Managers include:\n\nEconManager : an \"economically rational\" actor that optimizes for farm profit\nRigidManager : applies a pre-determined volume of water every time step\n\nParameters at the field-level may be defined as:\n\nRealParameter, inputs that have a range of possible values\nCategoricalParameter, similar to RealParameter except that the range of values relate to specific \"options\"\nConstantParameter, parameters that are held constant for a simulation.\n\nNote that all dates follow YYYY-mm-dd format, or (mm-dd) if year is not specified.","category":"section"},{"location":"getting_started/#Required-data","page":"Getting Started","title":"Required data","text":"","category":"section"},{"location":"getting_started/#Zones","page":"Getting Started","title":"Zones","text":"CSV of climate data for each zone (daily ET and rainfall, assumed daily)\nEstimated Total Available Water for each field's soil type\nInitial soil water deficit for each field","category":"section"},{"location":"getting_started/#Fields","page":"Getting Started","title":"Fields","text":"Access costs for each water source\nOperational costs of pumping from surface and groundwater\nOperational costs of each irrigation system\nCrop parameters","category":"section"},{"location":"getting_started/#Water-allocations/policy","page":"Getting Started","title":"Water allocations/policy","text":"Agtor requires a water allocation model to be provided by the user. This can represent a given policy, regional management approach, or other situation.\n\nThe example function below simply resets the water entitlement for a given zone/watersource on 1 May ((5, 1)) every year.\n\n\"\"\"Reallocate water on given date.\n\nExample proxy for a policy model which is called every time step\nfor the given zone.\n\nWater allocations are simply reset at start of season (1 May).\n\"\"\"\nfunction reset_allocation!(zone, dt_i; gs_start=(5, 1))\n    # Resetting allocations for each growing season\n    if monthday(dt_i) == gs_start\n        # Full annual water allocations each year\n        tmp = LittleDict(ws.name=>ws.entitlement for ws in zone.water_sources)\n        t_names = Tuple(Symbol.(collect(keys(tmp))))\n        allocs = NamedTuple{t_names}(collect(values(tmp)))\n\n        update_available_water!(zone, allocs)\n    end\nend","category":"section"},{"location":"getting_started/#Defining-Components","page":"Getting Started","title":"Defining Components","text":"All components for Agtor are defined through YAML files which act as the specifications of each component.\n\nSee Example Component Specifications for an outline of each spec.\n\nSpecifications are loaded from the collection of YAML files as a dictionary. A Basin may therefore be defined directly as a dictionary so long as it follows component specifications as outlined in Example Component Specifications.","category":"section"},{"location":"getting_started/#Example:-Running-scenarios","page":"Getting Started","title":"Example: Running scenarios","text":"At the highest level of use, Agtor runs multiple simulations (\"scenarios\").\n\nusing Agtor\n\n# Load Basin specification from its directory\nbasin_spec_dir = \"examples/campaspe/basin/\"\n\n# A directory may hold specs for multiple basins.\n# Here, we are loading the Campaspe spec (the only one defined in the directory)\nbasin_spec = load_spec(basin_spec_dir)[:Campaspe]\n\n# Extract name and zone specs\nbasin_name = basin_spec[:name]\nzone_specs = basin_spec[:zone_spec]\n\n# Specify location of shared climate data for all zones\nclimate_data = \"examples/campaspe/climate/basin_historic_climate_data.csv\"\n\n# Create an \"economically rational\" manager to be shared by all zones.\n# This manager optimizes returns for the available water, given water needs and costs.\nOptimizingManager = EconManager(\"optimizing\")\n\n# We then assign this manager to all zones defined in the basin spec\n# this associate a set of zones to a given manager by the zone name\n# associate_managers([OptimizingManager], [[:Zone_1, :Zone_2, ..., :Zone_N]])\nmanage_zones = associate_managers([OptimizingManager], [keys(zone_specs)])\n\n# Multiple associations can be created:\n# associate_managers(\n#    [OptimizingManager, RigidManager],\n#    [[:Zone_1, :Zone_2], [:Zone_3, ..., :Zone_N]])\n\n# Final step in the setup is to create the basin by specifying its name, the zones, \n# the climate data and the manager-zone relationship defined above.\ncampaspe_basin = Basin(name=basin_name, zone_spec=zone_specs, \n                       climate_data=climate_data, managers=manage_zones)\n\n# We then create/run scenarios by sampling from possible parameter combinations\n# We use the `Surrogates` package for the sampling:\nagparams = collect_agparams!(campaspe_basin)  # collect all parameters\nsamples = sample(50, agparams[:, :min_val], agparams[:, :max_val], SobolSample())\n\n# Match sampled values with parameter names\ndf = rename!(DataFrame(samples), map(Symbol, agparams[:, :name]))\n\n# Run all defined scenarios\nres = run_scenarios!(df, campaspe_basin; pre=reset_allocation!)\n\nNote that the example water allocation model was passed into the pre argument. Agtor defines pre and post and in cases functions are supplied, these are run before each time step (in the case of pre) or after each time step (in the case of post).\n\nScenario results are held in the form of a dictionary with entries for aggregate zone level results...\n\njulia> res\nDict{Any, Any} with 100 entries:\n  \"46/field_results\" => Dict{String, Dict{String, DataFrame}}(\"Zone_5\"=>Dict(\"field1\"=>36×8 DataFrame…\n  \"12/zone_results\"  => Dict{String, DataFrame}(\"Zone_5\"=>36×13 DataFrame…\n\njulia> res[\"1/zone_results\"]\nDict{String, DataFrame} with 12 entries:\n  \"Zone_5\"  => 36×13 DataFrame…\n  \"Zone_2\"  => 36×15 DataFrame…\n  \"Zone_12\" => 36×13 DataFrame…\n\n... and results for each field for a given zone. In other words, finer-scale field level results:\n\njulia> res[\"1/field_results\"][\"Zone_5\"]\nDict{String, DataFrame} with 1 entry:\n  \"field1\" => 36×8 DataFrame…","category":"section"},{"location":"getting_started/#Example:-Within-scenario/timestep","page":"Getting Started","title":"Example: Within scenario/timestep","text":"Finer-grain simulations are also possible with Agtor.\n\n# Update the zone with some new parameter values if necessary\n# update_model!(zone, some_parameters)\nzone_results, field_results = run_model(OptimizingManager, zone; post=reset_allocation!)\n\n# Run a specific timestep\nrun_timestep!(OptimizingManager, zone, timestep_id, timestep_date);\n\nwarning: Warning\nIn the case of running a timestep, all time stepping and  data handling is left to the user to specify.See example below.","category":"section"},{"location":"getting_started/#Example-custom-run-function","page":"Getting Started","title":"Example custom run function","text":"# Define growing season start as 1 May\nconst gs_start = (5, 1);\n\nfunction run_model(zone)\n    time_sequence = zone.climate.time_steps\n\n    # Example annual water allocations\n    allocs = (surface_water=150.0, groundwater=40.0)\n\n    for (idx, dt_i) in enumerate(time_sequence)\n        run_timestep!(zone.manager, zone, idx, dt_i)\n\n        # Resetting allocations for example run\n        if monthday(dt_i) == gs_start\n            update_available_water!(zone, allocs)\n        end\n    end\n\n    zone_results, field_results = collect_results(zone)\n\n    return zone_results, field_results\nend","category":"section"},{"location":"#Agtor.jl","page":"Agtor.jl","title":"Agtor.jl","text":"Agtor is an actor-based zonal agricultural cropping/water management model.","category":"section"},{"location":"#Description","page":"Agtor.jl","title":"Description","text":"Agtor is designed to facilitate interdisciplinary exploratory scenario modelling of agricultural systems and related system interactions. Agtor operates at a zonal scale where the zone may represent an individual farm/field, sub-catchment area, or the catchment itself.\n\nBased on an earlier version developed for the Lower Campaspe region in North-Central Victoria. See this paper.\n\nContributions are welcome.","category":"section"},{"location":"#Why-the-name-\"Agtor\"?","page":"Agtor.jl","title":"Why the name \"Agtor\"?","text":"The model represents agricultural actors within a system and so the name is a portmandeau of \"agriculture\" and \"actor\".","category":"section"},{"location":"API/#Agtor-API","page":"Agtor API","title":"Agtor API","text":"","category":"section"},{"location":"API/#Agtor.CategoricalParameter","page":"Agtor API","title":"Agtor.CategoricalParameter","text":"CategoricalParameter\n\nMin and max values will map to (integer) element position in an CategoricalArray.\n\nSampling between the min and max values will be mapped to their categorical value in the given array using floor() of the Float value x.\n\nValid values for the CategoricalParameter will therefore be:  1 <= x < (n+1), where n is number of options.\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.Climate","page":"Agtor API","title":"Agtor.Climate","text":"Serves as an interface to climate data\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.EconManager","page":"Agtor API","title":"Agtor.EconManager","text":"An 'economically rational' crop farm manager.\n\nWater is applied for optimal farm profitability based on soil water deficit, crop water requirements, and cost of water application.\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.Infrastructure","page":"Agtor API","title":"Agtor.Infrastructure","text":"Represents generic farm infrastructure.\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.Irrigation","page":"Agtor API","title":"Agtor.Irrigation","text":"On-farm irrigation infrastructure component\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.Pump","page":"Agtor API","title":"Agtor.Pump","text":"Pump(pump_efficiency=0.7, cost_per_kW=0.28, derating=0.75)\n\nAn on-farm pump to access water.\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.RigidManager","page":"Agtor API","title":"Agtor.RigidManager","text":"A rigid farm manager.\n\nWater is applied by a pre-determined quantity rather than optimal profitability. Uses surface water first, then groundwater.\n\n\n\n\n\n","category":"type"},{"location":"API/#Agtor.ML_water_application_cost-Tuple{Manager, FarmZone, FarmField, Float64}","page":"Agtor API","title":"Agtor.ML_water_application_cost","text":"ML_water_application_cost(m::Manager, zone::FarmZone, field::FarmField, req_water_ML_ha::Float64)::NamedTuple\n\nCalculate water application cost/ML by each water source.\n\nReturns\n\nWater source name and cost per ML/ha\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.add_prefix!-Tuple{String, Any}","page":"Agtor API","title":"Agtor.add_prefix!","text":"Modify AgParameter name in place by adding a prefix.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.agin-Tuple{AgParameter, Array}","page":"Agtor API","title":"Agtor.agin","text":"agin(p::AgParameter, store::Array)::Bool\n\nAgtor specific in function.\n\nPurposeful decision not to override Base.in() method as this performs the check on any Array expecting NamedTuples.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.apply_irrigation!-Tuple{CropField, WaterSource, Float64, Float64}","page":"Agtor API","title":"Agtor.apply_irrigation!","text":"apply_irrigation!(\n    field::CropField,\n    ws::WaterSource,\n    water_to_apply_mm::Float64,\n    area_to_apply::Float64\n)::Nothing\n\nApply irrigation water to field.\n\nArguments\n\nfield : Field\nws : Water Source\nwater_to_apply_mm : Volume of water to apply (in mm) with irrigation efficiencies considered.\narea_to_apply: Area irrigation occurs over\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.apply_rainfall!-Tuple{FarmZone, Dates.Date}","page":"Agtor API","title":"Agtor.apply_rainfall!","text":"Apply rainfall and ET to influence soil water deficit.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.apply_rainfall!-Tuple{FarmZone, Int64}","page":"Agtor API","title":"Agtor.apply_rainfall!","text":"Apply rainfall and ET to influence soil water deficit.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.assign_managers!-Tuple{Any, Any}","page":"Agtor API","title":"Agtor.assign_managers!","text":"Example\n\n# Load zone specifications\nzone_specs = load_spec(\"test/data/zones\")\n\n# Define managers of interest\nManager_A = EconManager(\"optimizing\")\nManager_B = RigidManager(\"rigid\", 0.05)\n\n# Create tuple-based relation between managers and zones (by name)\nmanage_zones = ((Manager_A, (\"Zone_1\", )), (Manager_B, (\"Zone_2\", \"Zone_3\")))\n\n# Attach managers to their associated zones\nassign_managers!(manage_zones, values(zone_specs))\n\nRaises ArgumentError if duplicate zone names are found.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.associate_managers-Tuple{Any, Any}","page":"Agtor API","title":"Agtor.associate_managers","text":"associate_managers(managers, zones)\n\nMap a given list of managers to a list of zones.\n\nExample\n\nOptimizingManager = EconManager(\"optimizing\")\nmanage_zones = associate_managers([OptimizingManager], [[:Zone_1, :Zone_2]])\n\nArguments\n\nmanagers : list-like, of managers\nzones : list-like of a list of zone names to associate a manager with\n\nReturns\n\nTuple of tuples of managers and the names of zones they manage\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.calc_ML_pump_costs-Tuple{Manager, FarmZone, Float64}","page":"Agtor API","title":"Agtor.calc_ML_pump_costs","text":"Calculate pumping costs (per ML) for each water source.\n\nArguments\n\nm : manager component\nzone : FarmZone\nflow_rate_Lps : float, desired flow rate in Litres per second.\n\nReturns\n\nDict{String,Float64} : Cost of pumping per ML for each water source.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.calc_potential_crop_yield-Tuple{Function}","page":"Agtor API","title":"Agtor.calc_potential_crop_yield","text":"calc_potential_crop_yield(method::Function; kwargs...)\n\nCalculate potential crop yield using an arbitrary function. This function enables a consistent interface to be provided.\n\nFunction must return a Tuple of results or a Float64\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.calc_required_water-Tuple{FarmField, Dates.Date}","page":"Agtor API","title":"Agtor.calc_required_water","text":"calc_required_water(f::FarmField, dt::Date)\n\nVolume of water to maintain moisture above net irrigation depth (nid).\n\nCalculates volume of water needed to replenish soil water deficit (swd) when SWD falls below nid, considering irrigation efficiency.\n\nValues are given in mm.\n\nlink to nid(f::FarmField, dt::Date)\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_by_scenario-Tuple{Union{Dict, OrderedCollections.OrderedDict}, String}","page":"Agtor API","title":"Agtor.collate_by_scenario","text":"collate_by_scenario(results::DICT_TYPE, metric::String; res_type::String=\"zone_results\")::OrderedDict\n\nCollate results for each result type (res_type).\n\nExample\n\nres = run_scenarios!(df, campaspe_basin; pre=allocation_precall!)\nzone_results = collate_by_scenario(res, \"irrigated_volume_sum\")\n# OrderedDict{String, DataFrame} with 2 entries:\n#    \"1\" => 36×13 DataFrame…\n#    \"2\" => 36×13 DataFrame…\n#\n#\n# where each DataFrame contains results of the metric of interest by zone:\n#\n# 36×13 DataFrame\n#  Row │ Date        Zone_9    Zone_8    Zone_6    Zone_5    Zone_1    Zone_2    Zone_3    Zone_10        Zone_12   Zone_4  ⋯\n#      │ Date        Float64?  Float64?  Float64?  Float64?  Float64?  Float64?  Float64?  Float64?       Float64?  Float64 ⋯\n# ─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n#    1 │ 1982-01-20   3028.48   70415.2    2023.6       0.0       0.0   13348.2       0.0      1.26215e5       0.0   6955.9 ⋯\n#    2 │ 1982-10-08   4497.18   35794.0    2023.6       0.0       0.0   13348.2       0.0  37563.1             0.0   6955.9\n#    3 │ 1983-10-13   4497.18   36483.7    2023.6       0.0       0.0   13348.2       0.0  36700.1             0.0   6955.9\n#    4 │ 1985-01-20   2854.3    70415.2    2023.6       0.0       0.0   13348.2       0.0      1.26121e5       0.0   6955.9\n#   ⋮  │     ⋮          ⋮         ⋮         ⋮         ⋮         ⋮         ⋮         ⋮            ⋮           ⋮         ⋮    ⋱\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_field_logs-Tuple{FarmZone, Symbol}","page":"Agtor API","title":"Agtor.collate_field_logs","text":"Collate logged values, summing on identical datetimes\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_field_logs-Tuple{FarmZone}","page":"Agtor API","title":"Agtor.collate_field_logs","text":"collate_field_logs(zone::FarmZone)::DataFrame\ncollate_field_logs(seasonal_logs::Dict)::DataFrame\n\nCollate logged values, aggregating to the zonal level based on identical datetimes.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_results!-Tuple{String, String}","page":"Agtor API","title":"Agtor.collate_results!","text":"collate_results!(fn_pattern::String, main_fn::String)::Nothing\n\nCollate individually saved .jld2 files from distributed runs into a single JLD2 file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_results-Tuple{String, String, Array{String}}","page":"Agtor API","title":"Agtor.collate_results","text":"collate_results(fn::String, group::String, target::Array{String})::DataFrame\ncollate_results(data::Dict, group::String, target::Array{String})::DataFrame\ncollate_results(fn::String, group::String, target::String)::DataFrame\ncollate_results(data::Dict, group::String, target::String)::DataFrame\n\nCollate a results from across scenario runs into an individual DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collate_scenario_results-Tuple{Union{Dict, OrderedCollections.OrderedDict}, String}","page":"Agtor API","title":"Agtor.collate_scenario_results","text":"collate_scenario_results(results::DICT_TYPE, metric::String; op=sum)::DataFrame\n\nCollate metric of interest for each scenario, aggregated by op.\n\nExample\n\nres = run_scenarios!(df, campaspe_basin; pre=allocation_precall!)\nscen_results = collate_scenario_results(res, \"income_sum\")\n# 36×3 DataFrame\n#  Row │ Date        1           2\n#      │ Date        Float64     Float64\n# ─────┼────────────────────────────────────\n#    1 │ 1982-01-20  -1.14443e7  -3.83782e6\n#    2 │ 1982-10-08  -6.23264e6   1.77937e6\n#    3 │ 1983-10-13  -1.04992e7  -3.17234e6\n#    4 │ 1985-01-20  -1.31009e8  -3.82679e6\n#   ⋮  │     ⋮           ⋮           ⋮\n#   33 │ 2013-10-13  -1.10069e7  -3.67198e6\n#   34 │ 2015-01-20  -1.31051e8  -3.93724e6\n#   35 │ 2015-10-08  -1.25556e8   1.77678e6\n#   36 │ 2016-10-13  -1.0844e7   -3.52039e6\n#                            28 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_agparams!-Tuple{Dict, Dict}","page":"Agtor API","title":"Agtor.collect_agparams!","text":"collect_agparams!(dataset::Dict, mainset::Dict)::Nothing\n\nExtract parameter values from Dict specification and store in a common Dict.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_agparams!-Tuple{Union{AgComponent, AgParameter}, Array}","page":"Agtor API","title":"Agtor.collect_agparams!","text":"Extract parameter values from AgComponent.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_agparams!-Tuple{Union{Tuple, Array}, Array}","page":"Agtor API","title":"Agtor.collect_agparams!","text":"collect_agparams!(dataset::Union{Array, Tuple}, store::Array; ignore::Union{Array, Nothing}=nothing)::Nothing\ncollect_agparams!(dataset::Dict, store::Array; ignore::Union{Array, Nothing}=nothing)::DataFrame\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_agparams-Tuple{Dict}","page":"Agtor API","title":"Agtor.collect_agparams","text":"collect_agparams(dataset::Dict; ignore::Union{Array, Nothing}=nothing)::DataFrame\n\nExtract parameter values from Dict specification.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_results-Tuple{Basin}","page":"Agtor API","title":"Agtor.collect_results","text":"Collect model run results for a Basin\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.collect_results-Tuple{FarmZone}","page":"Agtor API","title":"Agtor.collect_results","text":"Collect model run results for a FarmZone\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.component_relationship-Tuple{DataFrames.DataFrame}","page":"Agtor API","title":"Agtor.component_relationship","text":"Create relational mapping between components and values.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.ensure_date-Tuple{Climate, String, String}","page":"Agtor API","title":"Agtor.ensure_date","text":"Converts strings to datetime.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.estimate_income_per_ha-Tuple{Crop}","page":"Agtor API","title":"Agtor.estimate_income_per_ha","text":"Naive estimation of net income.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.extract_values-Tuple{AgParameter}","page":"Agtor API","title":"Agtor.extract_values","text":"Extract parameter values from AgParameter\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.french_schultz_cy-Tuple{}","page":"Agtor API","title":"Agtor.french_schultz_cy","text":"french_schultz_cy(; ssm_mm::Float64, gsr_mm::Float64, crop::AgComponent)\n\nPotential crop yield calculation based on a modified French-Schultz equation. The implemented method is the farmer-friendly version as described by Oliver et al., (2008) (see [1]).\n\nYP = (SSM + GSR - E) * WUE\n\nwhere\n\nYP is yield potential in tonnes per hectare\nSSM is Stored Soil Moisture (at start of season) in mm, assumed to be 30% of summer rainfall\nGSR is Growing Season Rainfall in mm\nE is Crop Evaporation coefficient in mm, the amount of rainfall required before the crop will start   to grow, commonly 110mm, but can range from 30-170mm (see [2]),\nWUE is Water Use Efficiency coefficient in kg/mm\n\nReferences\n\nOliver et al. (2008) (see Equation 1)\nWhitbread and Hancock (2008)\n\nArguments\n\nssm_mm : float, Stored Soil Moisture (mm) at start of season.\ngsr_mm : float, Growing Season Rainfall (mm)\ncrop : object, Crop component object\n\nReturns\n\nPotential yield in tonnes/Ha\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.generate_agparams-Tuple{Union{String, Symbol}, Dict}","page":"Agtor API","title":"Agtor.generate_agparams","text":"Generate AgParameter definitions.\n\nArguments\n\nprefix : str\ndataset : Dict, of parameters for given component\n\nReturns\n\nDict matching structure of dataset\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.get_optimum_irrigated_area-Tuple{FarmField, OrderedCollections.OrderedDict}","page":"Agtor API","title":"Agtor.get_optimum_irrigated_area","text":"Extract total irrigated area from OptLang optimized results.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.get_season_range-Tuple{Climate, Dates.Date, Dates.Date}","page":"Agtor API","title":"Agtor.get_season_range","text":"Gets climate data for season range.\n\nArguments\n\np_start : datetime, start of range in Y-m-d format, inclusive.\np_end : datetime, end of range in Y-m-d format, inclusive.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.get_seasonal_et-Tuple{Climate, Vector{Dates.Date}, String}","page":"Agtor API","title":"Agtor.get_seasonal_et","text":"Retrieve seasonal evapotranspiration.\n\nArguments\n\nseason_range : List-like, start and end dates, can be string or datetime object\npartial_name : str, string to (partially) match column name identifier on\n\nReturns\n\nnumeric of seasonal rainfall\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.get_seasonal_rainfall-Tuple{Climate, Vector{Dates.Date}, String}","page":"Agtor API","title":"Agtor.get_seasonal_rainfall","text":"Retrieve seasonal rainfall by matching column name. Columns names are expected to have 'rainfall' with some identifier.\n\nExample\n\nWhere column names are: 'rainfallfield1', 'rainfallfield2', ...\n\nget_seasonal_rainfall(c, ['1981-01-01', '1982-06-01'], 'field1')\n\nArguments\n\nseason_range : List-like, start and end dates, can be string or datetime object\npartial_name : str, string to (partially) match column name identifier on\n\nReturns\n\nnumeric, representing seasonal rainfall\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.gross_income","page":"Agtor API","title":"Agtor.gross_income","text":"gross_income(\n    f::FarmField, area::Float64, func::Function=french_schultz_cy; kwargs...\n)::Tuple{Float64}\n\nCalculate gross income and crop yield using an arbitrary crop yield function.\n\nReturns\n\nTuple{Float64} : income [/yield], total_yield [t]\n\n\n\n\n\n","category":"function"},{"location":"API/#Agtor.gross_income-Tuple{FarmField, Float64, Float64, Float64}","page":"Agtor API","title":"Agtor.gross_income","text":"gross_income(\n    f::FarmField,\n    ssm_mm::Float64,\n    gsr_mm::Float64,\n    irrig::Float64;\n    func::Function=french_schultz_cy\n)::Tuple\n\nCalculate gross income, potential irrigated yield, and potential dryland yield.\n\nReturns\n\nTuple{Float64} : income, irrigated yield [t], dryland yield [t]\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.in_season-Tuple{Dates.Date, Dates.Date, Dates.Date}","page":"Agtor API","title":"Agtor.in_season","text":"Check to see if given date is between start and end dates (exclusive of start and end)\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.in_season_dates-Tuple{Climate, Crop}","page":"Agtor API","title":"Agtor.in_season_dates","text":"Get all in-season dates for a given crop.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.irrigated_area-Tuple{FarmZone}","page":"Agtor API","title":"Agtor.irrigated_area","text":"The total area marked for irrigation.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.is_const-Tuple{AgParameter}","page":"Agtor API","title":"Agtor.is_const","text":"Checks if parameter is constant.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.log_irrigation_by_water_source-Tuple{FarmZone, FarmField, Dates.Date}","page":"Agtor API","title":"Agtor.log_irrigation_by_water_source","text":"Log irrigation volumes from water sources\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.log_irrigation_cost-Tuple{FarmField, Float64}","page":"Agtor API","title":"Agtor.log_irrigation_cost","text":"Log the (total) cost of irrigation.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.maintenance_cost-Tuple{Infrastructure, Int64}","page":"Agtor API","title":"Agtor.maintenance_cost","text":"Calculate maintenance costs.\n\nwarning: Warning\nDon't forget that the output of this can be on a per hectare basis  or given as a total depending on how the model is parameterized.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.matching_dates-Tuple{Dates.Date, Dates.Date}","page":"Agtor API","title":"Agtor.matching_dates","text":"Check to see if two dates are identical\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.min_max-Tuple{AgParameter}","page":"Agtor API","title":"Agtor.min_max","text":"min_max(p::AgParameter)\nmin_max(dataset::Dict)::Dict\n\nReturns min/max of parameter values.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.nid-Tuple{FarmField, Dates.Date}","page":"Agtor API","title":"Agtor.nid","text":"nid(f::FarmField, dt::Date)::Float64\n\nCalculate net irrigation depth in mm, 0.0 or above.\n\nEquation taken from Agriculture Victoria\n\nSee also:\n\nhttp://www.fao.org/docrep/x5560e/x5560e03.htm\nhttps://www.bae.ncsu.edu/programs/extension/evans/ag452-1.html\nhttp://dpipwe.tas.gov.au/Documents/Soil-waterfactsheet14122011a.pdf\nhttps://www.agric.wa.gov.au/water-management/calculating-readily-available-water?nopaging=1\n\nNID = Effective root depth (D_rz) * Readily Available Water (RAW)\n\nwhere:\n\nD_rz = Crop_root depth * Crop_e_rz, where Crop_root depth is the estimated root depth for current stage of crop (initial, late, etc.) and Crop_e rz is the effective root zone coefficient for the crop.\nCrop_e rz is said to be between 1 and 2/3rds of total root depth\nRAW = p * TAW, p is depletion fraction of crop, TAW is Total Available Water in Soil\n\nAs an example, if a crop has a root depth (RD_r) of 1m, an effective root zone (RD_erz) coefficient of 0.55, a depletion fraction (p) of 0.4 and the soil has a TAW of 180mm:\n\n(RD_r * RD_erz) * (p * TAW)\n\nWorks out to be:\n\n(1 * 055) * (04 * 180)\n\nReturns\n\nnet irrigation depth (in mm)\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.optimize_irrigated_area-Tuple{Manager, FarmZone}","page":"Agtor API","title":"Agtor.optimize_irrigated_area","text":"Apply Linear Programming to naively optimize irrigated area.\n\nOccurs at start of season.\n\nArguments\n\nm : Agtor.Manager,\nzone : Agtor.FarmZone, representing a farm or a farming zone.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.optimize_irrigation-Tuple{Manager, FarmZone, Dates.Date}","page":"Agtor API","title":"Agtor.optimize_irrigation","text":"optimize_irrigation(m::Manager, zone::FarmZone, dt::Date)::Tuple{OrderedDict, NamedTuple}\n\nApply Linear Programming to optimize irrigation water use.\n\nResults can be used to represent percentage mix e.g. if the field area is 100 ha, and the optimal area to be         irrigated by a water source is\n\nSW: 70 ha\nGW: 30 ha\n\nand the required amount is 20mm\n\nSW: 70 / 100 = 0.7 (irrigated area / total area, 70%)\nGW: 30 / 100 = 0.3 (30%)\n\nThen the per hectare amount to be applied from each water source is calculated as:\n\nSW = 20mm * 0.7\n   = 14mm\n\nGW = 20mm * 0.3\n   = 6mm\n\nArguments\n\nzone : FarmZone\ndt : datetime object, current datetime\n\nReturns\n\nTuple\n\nOrderedDict{String, Float64} keys based on field and water source names values are hectare area\n/\nML cost of applying water\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.perc_irrigation_sources-Tuple{Manager, FarmField, Array, Dict}","page":"Agtor API","title":"Agtor.perc_irrigation_sources","text":"Calculate percentage of area to be watered by a specific water source.\n\nReturns\n\nName of water source as key and percent area as value\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.possible_area_by_allocation-Tuple{FarmZone, FarmField, Float64}","page":"Agtor API","title":"Agtor.possible_area_by_allocation","text":"Determine the possible irrigation area using water from each water source.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.possible_irrigation_area-Tuple{FarmField, Float64, Float64}","page":"Agtor API","title":"Agtor.possible_irrigation_area","text":"Possible irrigation area in hectares.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.pumping_costs_per_ML-Tuple{Pump, Float64}","page":"Agtor API","title":"Agtor.pumping_costs_per_ML","text":"pumping_costs_per_ML(p::Pump, head_pressure::Float64)::Float64\n\nCalculate the energy cost to pump one megalitre of water.\n\nThe energy required to pump water is determined by the head pressure (vertical lift plus friction losses) and system efficiency, independent of flow rate.\n\nEnergy per megalitre:\n\nkWhML = (H  2725)  (η_pump  D)\n\nwhere:\n\nH is total head pressure in metres (m)\n2.725 is the gravitational constant: (g × ρ) / kWh = (9.81 m/s² × 1000 kg/m³) / 3,600,000 J/kWh\nη_pump is pump efficiency (typically 0.65-0.85)\nD is the derating factor accounting for motor and drive losses (typically 0.75-0.95)\n\nCost per megalitre:\n\nCostML = (kWhML)  (electricity rate in kWh)\n\nSee:     * Robinson, D. W. (2002)     * Vic. Dept. Agriculture (2006)     * Vellotti & Kalogernis (2013)\n\nArguments\n\np : Pump object containing efficiency, derating, and electricity cost parameters\nhead_pressure : Total dynamic head in metres (static lift + pressure head + friction losses)\n\nParameters taken from p::Pump\n\npump_efficiency : Efficiency of pump. Defaults to 0.7 (70%)\nderating : Accounts for efficiency losses between the energy required at the pump                   shaft and the total energy required. Defaults to 0.75\n\nReturns\n\nfloat, costperML\n\nNotes\n\nFlow rate does not affect cost per ML - it only affects pumping duration\nHigher head pressures increase energy requirements linearly\nPoor efficiency (pump or motor) significantly increases costs\nFor gravity-fed systems where H ≈ 0, pumping costs approach zero\n\nSee also\n\nlink to Pump(pump_efficiency, cost_per_kW, derating)\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.run_model-Tuple{Basin}","page":"Agtor API","title":"Agtor.run_model","text":"Run scenario for an entire basin.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.run_model-Tuple{FarmZone}","page":"Agtor API","title":"Agtor.run_model","text":"run_model(zone::FarmZone; ts_func::Function=run_timestep!, pre::Union{Function, Nothing}=nothing, post::Union{Function, Nothing}=nothing)::NamedTuple\n\nRun model for a single zone.\n\nArguments\n\nzone : Zone AgComponent\ntsfunc : Function, defining actions for a time step.       Must accept a Manager, zone, int, and Date/DateTime       `tsfunc(manager, zone, idx, dt)`       All operations must be in-place as changes will not propagate.\npre : Function, defines additional actions for zone that occur       at end of time step dt_i:       callback_func(zone, dt_i)\npost : Function, defines additional actions for zone that occur        at end of time step dt_i:        callback_func(zone, dt_i)\n\nReturns\n\nNamedTuple : results\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.run_scenarios!-Tuple{DataFrames.DataFrame, Basin}","page":"Agtor API","title":"Agtor.run_scenarios!","text":"run_scenarios!(samples::DataFrame, basin::Basin, ts_func::Function;\n               pre::Union{Function, Nothing}=nothing, post::Union{Function, Nothing}=nothing)::Dict\n\nRun basin level scenarios for a given sample set.\n\nReturns\n\nDict with keys:   \"scenarioid/zoneresults\" = zone level results for each zone in basin   \"scenarioid/fieldresults\" = field level results for each zone in basin\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.run_scenarios!-Tuple{DataFrames.DataFrame, FarmZone}","page":"Agtor API","title":"Agtor.run_scenarios!","text":"run_scenarios!(samples::DataFrame, zone::FarmZone; ts_func::Function=run_timestep!,\n               pre::Union{Function, Nothing}=nothing, post::Union{Function, Nothing}=nothing)::Dict\n\nRun zone level scenarios for a given sample set.\n\nReturns\n\nDict with keys:     - \"scenarioid/zoneresults\" = zone level results     - \"scenarioid/fieldresults\" = field level results\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.run_timestep!-Tuple{Basin, Any}","page":"Agtor API","title":"Agtor.run_timestep!","text":"Run timestep for all zones within a basin.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_results!-NTuple{5, Any}","page":"Agtor API","title":"Agtor.save_results!","text":"Save results for a scenario, basin, and zone combination\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_results!-Tuple{String, Any, Tuple{String, String}}","page":"Agtor API","title":"Agtor.save_results!","text":"Save arbitrary results to JLD.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_results!-Tuple{String, Dict}","page":"Agtor API","title":"Agtor.save_results!","text":"Save results to JLD2.\n\nExample\n\noutput_fn = \"example.jld2\"\nresults = run_scenarios!(samples, z1, run_timestep!; post=allocation_callback!)\nsave_results!(output_fn, results)\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_results!-Tuple{String, NamedTuple}","page":"Agtor API","title":"Agtor.save_results!","text":"Save arbitrary results to JLD.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_results!-Tuple{String, Union{Int64, String}, NamedTuple}","page":"Agtor API","title":"Agtor.save_results!","text":"Save results for a single zone to JLD.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.save_state!-Tuple{String, Any, String}","page":"Agtor API","title":"Agtor.save_state!","text":"Save state to JLD\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.scenario_stats-Tuple{DataFrames.DataFrame, String}","page":"Agtor API","title":"Agtor.scenario_stats","text":"Get aggregate statistics for an entire scenario run.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.seasonal_field_log!-Tuple{FarmField, Dates.Date, Vararg{Float64, 5}}","page":"Agtor API","title":"Agtor.seasonal_field_log!","text":"Log seasonal results.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.select_results-Tuple{DataFrames.DataFrame, String}","page":"Agtor API","title":"Agtor.select_results","text":"Filter DataFrame down to a subset of results based on partial column name match.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.set_next_crop!-Tuple{Manager, FarmField, Dates.Date}","page":"Agtor API","title":"Agtor.set_next_crop!","text":"Sets next crop in rotation and updates sowing/planting dates.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.set_params!-Tuple{Any, Any}","page":"Agtor API","title":"Agtor.set_params!","text":"set_params!(comp, sample)\nset_params!(comp::Array, sample)::Nothing\nset_params!(comp::Dict, sample)::Nothing\nset_params!(p::AgParameter, sample::Union{DataFrame, DataFrameRow})::Nothing\nset_params!(p::AgParameter, sample::Union{Number, String})::Nothing\nset_params!(p::AgParameter, sample::Union{Dict, NamedTuple})::Nothing\n\nNote\n\nupdate_model!(comp, sample) is an alias for set_params!(comp, sample)\n\nExample\n\nzone_dir = \"data_dir/zones/\"\nzone_specs = load_yaml(zone_dir)\nzone_params = generate_agparams(\"\", zone_specs[\"Zone_1\"])\n\ncollated_specs = []\ncollect_agparams!(zone_params, collated_specs; ignore=[\"crop_spec\"])\n\n# Expect only CSV for now...\nclimate_fn::String = \"data/climate/farm_climate_data.csv\"\nclimate::Climate = load_climate(climate_fn)\nz1 = create(zone_params, climate)\n\nparam_info = DataFrame(collated_specs)\n\n# Generate dataframe of samples\nsamples = sample(param_info, 1000, sampler)  # where sampler is some function\n\n# Update z1 components with values found in first row\nset_params!(z1, samples[1, :])\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.subtotal_costs-Tuple{Irrigation, Int64}","page":"Agtor API","title":"Agtor.subtotal_costs","text":"Calculate sub-total of irrigation costs\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.subtotal_costs-Tuple{WaterSource, Float64, Float64}","page":"Agtor API","title":"Agtor.subtotal_costs","text":"subtotal_costs(ws::WaterSource, area::Float64, water_used_ML::Float64)::Float64\n\nCalculate costs for irrigated area.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.total_costs-Tuple{FarmField, Dates.Date, Array{WaterSource}}","page":"Agtor API","title":"Agtor.total_costs","text":"Calculate total costs for a field.\n\nMaintenance costs can be spread out across a number of fields if desired.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.total_income-Tuple{FarmField, Float64, Float64, Float64, Tuple{Dates.Date, Vector{WaterSource}}}","page":"Agtor API","title":"Agtor.total_income","text":"total_income(\n    f::FarmField, ssm::Float64, gsr::Float64, irrig::Float64,\n    comps::Tuple{Date, Vector{WaterSource}}\n)::Tuple\n\nCalculate net income considering crop yield and costs incurred.\n\nReturns\n\nTuple:\n\nfloat : net income\nfloat : irrigated crop yield [t/ha]\nfloat : dryland crop yield [t/ha]\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.update_SWD!-Tuple{FarmField, Float64, Float64}","page":"Agtor API","title":"Agtor.update_SWD!","text":"update_SWD!(f::FarmField, rainfall::Float64, ET::Float64)\n\nCalculate soil water deficit, and update f.soil_SWD\n\nWater deficit is represented as positive values.\n\nrainfall and ET parameters are expected in mm.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.update_available_water!-Tuple{FarmZone, NamedTuple}","page":"Agtor API","title":"Agtor.update_available_water!","text":"Update water allocations\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.update_stages!-Tuple{Crop, Dates.Date}","page":"Agtor API","title":"Agtor.update_stages!","text":"Update growth stages with corresponding dates from given sowing date.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.use_allocation!-Tuple{WaterSource, Float64}","page":"Agtor API","title":"Agtor.use_allocation!","text":"Use allocation volume from a particular water source.\n\nVolumes in ML.\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.value_range-Tuple{AgParameter}","page":"Agtor API","title":"Agtor.value_range","text":"Returns max - min, or 0.0 if no min value defined\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.volume_used_by_source-Tuple{FarmField, String}","page":"Agtor API","title":"Agtor.volume_used_by_source","text":"Volume used from a water source in ML\n\n\n\n\n\n","category":"method"},{"location":"API/#Agtor.water_used_by_source-Tuple{FarmZone}","page":"Agtor API","title":"Agtor.water_used_by_source","text":"water_used_by_source(zone::FarmZone)::DataFrame\nwater_used_by_source(zone::FarmZone, dt)::DataFrame\n\nIdentify source of water used by a zone.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getproperty-Tuple{FarmField, Symbol}","page":"Agtor API","title":"Base.getproperty","text":"Getter for Field\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getproperty-Tuple{Irrigation, Symbol}","page":"Agtor API","title":"Base.getproperty","text":"Getters for Irrigation\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.setproperty!-Tuple{Agtor.CategoricalParameter, Symbol, Any}","page":"Agtor API","title":"Base.setproperty!","text":"Setter for CategoricalParameter to handle float to categorical element position.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.setproperty!-Tuple{FarmField, Symbol, Any}","page":"Agtor API","title":"Base.setproperty!","text":"Setter for Field\n\n\n\n\n\n","category":"method"}]
}
